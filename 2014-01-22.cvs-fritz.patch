### Eclipse Workspace Patch 1.0
#P CVSROOT
Index: commitinfo
===================================================================
RCS file: /srv/cvs/alldata/CVSROOT/commitinfo,v
retrieving revision 1.7
diff -u -r1.7 commitinfo
--- commitinfo	28 Sep 2004 08:41:52 -0000	1.7
+++ commitinfo	22 Jan 2014 17:06:03 -0000
@@ -15,3 +15,8 @@
 # in addition to the first matching regex or "DEFAULT".
 
 #^mbsejb /home/cvsuser/commitinfo.sh
+
+^jmbs /usr/java/jdk1.5.0_18/bin/java -classpath /home/cvsuser/cvs_alldata/alldev.jar:/home/cvsuser/cvs_alldata/db2jcc.jar:/home/cvsuser/cvs_alldata/mysql-jdbc.zip:/home/cvsuser/cvs_alldata/log4j.jar de.alldata.development.cvsutil.CvsUtil -configfile /home/cvsuser/cvs_alldata/CvsUtil.properties -branchmantis %{s}
+^jmbsSepa /usr/java/jdk1.5.0_18/bin/java -classpath /home/cvsuser/cvs_alldata/alldev.jar:/home/cvsuser/cvs_alldata/db2jcc.jar:/home/cvsuser/cvs_alldata/mysql-jdbc.zip:/home/cvsuser/cvs_alldata/log4j.jar de.alldata.development.cvsutil.CvsUtil -configfile /home/cvsuser/cvs_alldata/CvsUtil.properties -branchmantis %{s}
+^jmbsCustomizing /usr/java/jdk1.5.0_18/bin/java -classpath /home/cvsuser/cvs_alldata/alldev.jar:/home/cvsuser/cvs_alldata/db2jcc.jar:/home/cvsuser/cvs_alldata/mysql-jdbc.zip:/home/cvsuser/cvs_alldata/log4j.jar de.alldata.development.cvsutil.CvsUtil -configfile /home/cvsuser/cvs_alldata/CvsUtil.properties -branchmantis %{s}
+^CustomizingStandard /usr/java/jdk1.5.0_18/bin/java -classpath /home/cvsuser/cvs_alldata/alldev.jar:/home/cvsuser/cvs_alldata/db2jcc.jar:/home/cvsuser/cvs_alldata/mysql-jdbc.zip:/home/cvsuser/cvs_alldata/log4j.jar de.alldata.development.cvsutil.CvsUtil -configfile /home/cvsuser/cvs_alldata/CvsUtil.properties -branchmantis %{s}
#P alldev
Index: src/de/alldata/development/cvsutil/CvsUtil.java
===================================================================
RCS file: /srv/cvs/alldata/alldev/src/de/alldata/development/cvsutil/CvsUtil.java,v
retrieving revision 1.41
diff -u -r1.41 CvsUtil.java
--- src/de/alldata/development/cvsutil/CvsUtil.java	18 Oct 2011 07:10:59 -0000	1.41
+++ src/de/alldata/development/cvsutil/CvsUtil.java	22 Jan 2014 17:06:03 -0000
@@ -25,6 +25,7 @@
 import java.io.InputStreamReader;
 import java.sql.Connection;
 import java.sql.DriverManager;
+import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
@@ -32,9 +33,14 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.Properties;
 import java.util.ResourceBundle;
+import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.Vector;
 
@@ -137,6 +143,9 @@
 	/** support svn post-commit hook */
 	private static final int CVS_UTIL_SVN_POST_COMMIT = 12;
 
+	/** support branchmantis cvs utility */
+	private static final int CVS_UTIL_BRANCH_MANTIS = 13;
+
 	/** update vm-mantis-references in VM database */
 	private static final int UPDATE_VM_REF = 3;
 
@@ -184,22 +193,34 @@
 	private static String svn_DoMantisRegex = null;
 	private static Vector<String[]> svn_FilesVector = null;
 	private static boolean svn_DoIt;
+
+	//private static int retOk = 0;
+	private static int retErr = -1;
+	private static int stickyRevision = 1;
+	private static int headRevision = 2;
+
+	public static String mExists = "mExists";
+	public static String cvsBrCommit = "cvsBrCommit";
+	public static String mHasBrCommits = "mHasBrCommits";
+	public static String mHasHdCommits = "mHasHdCommits";
+	//public static String mHasPtKWord = "mHasPtKWord";
+	//public static String ptMantis = "ptMantis";
+	//public static String hdMantis = "hdMantis";
+	public static String isOk = "isOk";
 	
 	static {
-
-		try {
-			logger = Logger.getLogger(CvsUtil.class);
-			PropertyConfigurator.configure(System.getProperty("log4j.configuration"));
-		}catch (Exception e) {
-			;
+		logger = Logger.getLogger(CvsUtil.class);
+		String prop = System.getProperty("log4j.configuration");
+		if (prop != null) {
+			PropertyConfigurator.configure(prop);
 		}
 
 		try {
 			resBu = ResourceBundle.getBundle("resource.CvsUtil");
-
-		}catch (Exception e) {
-			if (logger != null)
-				logger.error("resource.CvsUtil file not found!");
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			logger.error(e.getMessage());
 		}
 	}
 
@@ -226,6 +247,7 @@
 
 	private static String cvsFiles = null;
 	private static String cvsLogList = null;
+	private static List<String> filesToCheck;
 
 	/**
 	 * Prints the program usage.
@@ -256,6 +278,8 @@
 				.println("  -user <user>         the cvs user name (for use with loginfo)");
 		System.out
 				.println("  -files <filelist>    the cvs files (for use with loginfo)");
+		System.out
+				.println("  -branchmantis        check if the commit-file branch/head destination corresponds with the mantis nr");
 		System.out.println("");
 	}
 
@@ -318,6 +342,17 @@
 				String tmpFileName = args[ii];
 				log(LEVEL_INFO, "commit message was sent to: " + tmpFileName);
 				verifyMessage = readFile(tmpFileName);
+			} else if (args[ii].equalsIgnoreCase("-branchmantis")) {
+				ii++;
+				filesToCheck = new ArrayList<String>();
+				//String msg = "";
+				for (; ii < args.length; ii++) {
+					String file = args[ii];
+					//msg += file + " ";
+					filesToCheck.add(file);
+				}
+				//log(LEVEL_INFO, "-branchmantis: filesToCheck: " + msg);
+				whichCvsUtil = CVS_UTIL_BRANCH_MANTIS;
 			} else if (args[ii].equalsIgnoreCase("-svn_pre_commit")) {
 				isSVN = true;
 				whichCvsUtil = CVS_UTIL_SVN_PRE_COMMIT;
@@ -1510,6 +1545,40 @@
 			verifyMsg();
 			//new CheckSeDTPolicies(mantisId, getMantisConnection(), );
 			break;
+		case CVS_UTIL_BRANCH_MANTIS:
+			boolean cvsBrCommit = false;
+//			for (Iterator<String> it = filesToCheck.iterator(); it.hasNext();) {
+//				String cvsFile = (String) it.next();
+//				int stickiness = getRevisionStickiness(cvsFile);
+//				boolean isBranchCommit = stickiness == CvsUtil.stickyRevision;
+//				log(LEVEL_INFO, "isBranchCommit: "+isBranchCommit+"; cvsFile: "+cvsFile);
+//				cvsBrCommit = cvsBrCommit || isBranchCommit;
+//			}
+
+//			mantisId = new Integer("24583"); // 24583 is a HEAD mantis
+//			mantisId = new Integer("25656"); // 24583 is a Patch mantis
+//			mantisId = new Integer("2458311"); // 2458311 does not exist
+			Map<String, String> r = new CvsUtil().checkBranchAgainstMantis(cvsBrCommit, mantisId);
+			String retVal = r.get(CvsUtil.isOk);
+			if (!(true+"").equals(retVal)) {
+				String s =
+				"Can't commit under mantis "+mantisId+":\n"+
+				rget(CvsUtil.mExists, r)+
+				rget(CvsUtil.cvsBrCommit, r)+
+				rget(CvsUtil.mHasBrCommits, r)+
+				rget(CvsUtil.mHasHdCommits, r)+
+				//rget(CvsUtil.mHasPtKWord, r)+
+				//rget(CvsUtil.ptMantis, r)+
+				//rget(CvsUtil.hdMantis, r)+
+				rget(CvsUtil.isOk, r)+
+				"";
+				log(LEVEL_ERROR, s);
+				System.exit(retErr);
+			}
+			else {
+				log(LEVEL_INFO, "Mantis ok: "+mantisId);
+			}
+			break;
 		case CVS_UTIL_SVN_POST_COMMIT:
 			svnGetUserAndFiles();
 			if (!svn_DoIt) {
@@ -1582,4 +1651,250 @@
 			}
 		}
 	}
+
+	public static int getRevisionStickiness(String cvsFile) {
+		boolean isSticky = false;
+		boolean isAnySticky = false;
+
+		Map<String, Boolean> stickyOptions = new HashMap<String, Boolean>();
+		stickyOptions.put("Sticky Tag", null);
+		stickyOptions.put("Sticky Date", null);
+		stickyOptions.put("Sticky Options", null);
+		Set<String> keys = stickyOptions.keySet();
+
+		try {
+			log(LEVEL_INFO, "Analyzing: cvs status "+cvsFile);
+			Process p = Runtime.getRuntime().exec("cvs status "+cvsFile);
+			p.waitFor();
+			BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
+			String line=reader.readLine();
+
+			while (line != null) {
+				for (Iterator<String> it = keys.iterator(); it.hasNext();) {
+					String stickyPrm = (String) it.next();
+					if (line.contains(stickyPrm)) {
+						int sepIdx = line.indexOf(":");
+						String stickyVal = line.substring(sepIdx+1);
+						if ("(none)".equals(stickyVal.trim())) {
+							isSticky = false;
+						} else {
+							isSticky = true;
+							isAnySticky = true;
+						}
+						// Collect all the sticky information (just for debugging purposes)
+						stickyOptions.put(stickyPrm, new Boolean(isSticky));
+					}
+				}
+				log(LEVEL_INFO, line);
+				line = reader.readLine();
+			}
+		}
+		catch(IOException e1) {
+			log(LEVEL_ERROR, e1.getMessage());
+			System.exit(retErr);
+		}
+		catch(InterruptedException e2) {
+			log(LEVEL_ERROR, e2.getMessage());
+			System.exit(retErr);
+		}
+
+		for (Iterator<String> it = keys.iterator(); it.hasNext();) {
+			String stickyPrm = (String) it.next();
+			Boolean bStickyVal = stickyOptions.get(stickyPrm);
+			if (bStickyVal == null) {
+				log(LEVEL_ERROR, "Could not detect value of: "+stickyPrm);
+				// TODO activate this in production 
+				System.exit(retErr);
+			}
+			else {
+				String stickyVal =  bStickyVal.booleanValue()+"";
+				log(LEVEL_INFO, stickyPrm +": "+stickyVal);
+			}
+		}
+		int stickiness = isAnySticky ? stickyRevision : headRevision;
+		log(LEVEL_INFO, "Stickiness (sticky="+stickyRevision+"; head="+headRevision+"): "+stickiness);
+		return stickiness; 
+	}
+
+	public Map<String, String> checkBranchAgainstMantis(boolean cvsBrCommit, Integer mantisId) {
+		if (mantisId == null) {
+			log(LEVEL_ERROR, "mantisId == null");
+			System.exit(retErr);
+		}
+		Map<String, String> r = new HashMap<String, String>();
+		boolean cvsHdCommit = !cvsBrCommit;
+
+		String sCoOnBr = "cvsBrCommit: "+cvsBrCommit;
+		log(LEVEL_INFO, "mantisId: "+mantisId+"; "+sCoOnBr);
+		String dbCol, sql;
+
+		// Patch mantis should contain 'Patch' in the name. Head mantis should not
+		//boolean mHasPtKWord = false;
+
+		boolean mExists = false;   // mantis exists
+		// Check for multiple '.' in deployment_mapping.mapping_version
+		boolean mHasBrCommits = false; // mantis contains branch commits
+		boolean mHasHdCommits = false; // mantis contains head commits
+
+		// Correspondence between info from sticky tags and mantis_bug_relationship_table 
+		boolean branch_vs_patch_indication_ok = false;
+
+		//final boolean hdMantis;
+		//final boolean ptMantis;
+
+		PreparedStatement stmt;
+		ResultSet rs;
+		Connection con = getMantisConnection();
+		try {
+			dbCol = "id";
+			sql = "select "+dbCol+" from mantis_bug_table where "+dbCol+" = ?";
+
+			stmt = con.prepareStatement(sql);
+			stmt.setInt(1, mantisId.intValue());
+			rs = stmt.executeQuery();
+
+			while (rs.next()) {
+				mExists = true;
+			}
+
+			if (mExists) {
+				dbCol = cvsBrCommit ? "destination_bug_id" : "source_bug_id";
+				sql = "select "+dbCol+" from mantis_bug_relationship_table where "+dbCol+" = ?";
+				stmt = con.prepareStatement(sql);
+				stmt.setInt(1, mantisId.intValue());
+				log(LEVEL_INFO, "sql: "+sql);
+				rs = stmt.executeQuery();
+
+				while (rs.next()) {
+					int dbColVal = rs.getInt(dbCol);
+					branch_vs_patch_indication_ok = mantisId.intValue() == dbColVal;
+					if (branch_vs_patch_indication_ok) {
+						break;
+					}
+				}
+
+//				dbCol = "summary";
+//				sql = "select "+dbCol+" from mantis_bug_table where id = ?";
+//				stmt = con.prepareStatement(sql);
+//				stmt.setInt(1, mantisId.intValue());
+//				log(LEVEL_INFO, "sql: "+sql);
+//				rs = stmt.executeQuery();
+//				while (rs.next()) {
+//					String patchName = rs.getString(dbCol);
+//					mHasPtKWord = patchName != null && patchName.startsWith("Patch");
+//					if (mHasPtKWord) {
+//						break;
+//					}
+//				}
+
+				dbCol = "mapping_version";
+				sql = "select "+dbCol+" from deployment_mapping where mapping_mantis_id = ?";
+				stmt = con.prepareStatement(sql);
+				stmt.setInt(1, mantisId.intValue());
+				log(LEVEL_INFO, "sql: "+sql);
+				rs = stmt.executeQuery();
+				while (rs.next()) {
+					String mappingVersion = rs.getString(dbCol);
+					if (mappingVersion != null) {
+						// cut off '1.' from version number and check for any dots
+						if (mappingVersion.substring(2).contains(".")) {
+							mHasBrCommits = true;
+						}
+						else {
+							mHasHdCommits = true;
+						}
+					}
+				}
+			}
+			rs.close();
+			stmt.close();
+		}
+		catch (SQLException e) {
+			log(LEVEL_ERROR, e.getMessage());
+			System.exit(retErr);
+		}
+
+		r.put(CvsUtil.mExists, mExists+"");
+		//r.put(CvsUtil.mHasPtKWord, mHasPtKWord+"");
+		r.put(CvsUtil.cvsBrCommit, cvsBrCommit+"");
+		r.put(CvsUtil.mHasBrCommits, mHasBrCommits+"");
+		r.put(CvsUtil.mHasHdCommits, mHasHdCommits+"");
+
+//		if (mExists) {
+//			if (!cvsBrCommit && !mHasPtKWord) {
+//				hdMantis = true;
+//				ptMantis = false;
+//			}
+//			else if (cvsBrCommit && mHasPtKWord) {
+//				hdMantis = false;
+//				ptMantis = true;
+//			}
+//			else {
+//				hdMantis = false;
+//				ptMantis = false;
+//			}
+//		}
+//		else {
+//			hdMantis = false;
+//			ptMantis = false;
+//		}
+
+//		r.put(CvsUtil.ptMantis, ptMantis+"");
+//		r.put(CvsUtil.hdMantis, hdMantis+"");
+//
+//		if (!hdMantis && !ptMantis) {
+//			r.put(CvsUtil.retVal, false+"");
+//			return r;
+//		}
+		
+		//if (mExists && cvsBrCommit && !mHasBrCommits && !mHasHdCommits && ptMantis) {
+		if (mExists && cvsBrCommit && !mHasBrCommits && !mHasHdCommits) {
+			//r.put(CvsUtil.ret, true+"");
+		}
+		//else if (mExists && cvsBrCommit && mHasBrCommits && !mHasHdCommits && ptMantis) {
+		else if (mExists && cvsBrCommit && mHasBrCommits && !mHasHdCommits) {
+			//r.put(CvsUtil.ret, true+"");
+		}
+		//else if (mExists && cvsHdCommit && !mHasBrCommits && !mHasHdCommits && hdMantis) {
+		else if (mExists && cvsHdCommit && !mHasBrCommits && !mHasHdCommits) {
+			//r.put(CvsUtil.ret, true+"");
+		}
+		//else if (mExists && cvsHdCommit && !mHasBrCommits && mHasHdCommits && hdMantis) {
+		else if (mExists && cvsHdCommit && !mHasBrCommits && mHasHdCommits) {
+			//r.put(CvsUtil.ret, true+"");
+		}
+		else {
+			r.put(CvsUtil.isOk, false+"");
+			return r;
+		}
+
+		if (mExists && !cvsBrCommit && !branch_vs_patch_indication_ok) {
+			r.put(CvsUtil.isOk, true+"");
+		}
+		else if (mExists && !cvsBrCommit && branch_vs_patch_indication_ok) {
+			r.put(CvsUtil.isOk, true+"");
+		}
+		else if (mExists && cvsBrCommit && branch_vs_patch_indication_ok) {
+			r.put(CvsUtil.isOk, true+"");
+		}
+		else {
+			r.put(CvsUtil.isOk, false+"");
+			return r;
+		}
+		return r;
+	}
+
+	private static String formatVal(String vr) {
+		return (true+"").equals(vr) ? "t" : "f";
+	}
+
+	private static String rget(String key, Map<String, String> r) {
+		return rget(key, r, null);
+	}
+
+	public static String rget(String key, Map<String, String> r, Map<String, String> e) {
+		String vr = CvsUtil.formatVal(r.get(key));
+		String ve = e == null ? "" : CvsUtil.formatVal(e.get(key));
+		return key+":" + vr + ve + " ";
+	}
 }
Index: src/de/alldata/development/cvsutil/CvsUtilTest.java
===================================================================
RCS file: src/de/alldata/development/cvsutil/CvsUtilTest.java
diff -N src/de/alldata/development/cvsutil/CvsUtilTest.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/de/alldata/development/cvsutil/CvsUtilTest.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,141 @@
+package de.alldata.development.cvsutil;
+import static org.junit.Assert.fail;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import org.junit.Test;
+
+public class CvsUtilTest {
+
+	@Test
+	public void test() {
+		CvsUtil.getConfigParameters("dist/CvsUtil.properties");
+
+		CvsUtil u = new CvsUtil();
+		// r, mr - obtained results; e, me - expected results
+		Map<Integer, Map<String, String>> mr = new HashMap<Integer, Map<String,String>>();
+		Map<Integer, Map<String, String>> me = new HashMap<Integer, Map<String,String>>();
+		Map<String, String> r, e;
+
+		Integer mantisId;
+		boolean do24583, do2458311, do24912, do24875, do25656;
+
+		do24875 = do24912 = do2458311 = do24583 = do25656 = false;
+		do24875 = do24912 = do2458311 = do24583 = do25656 = true;
+		//do25656 = true;
+
+		if (do25656) {
+			mantisId = new Integer("25656"); // 25656 is a Patch mantis
+			mr.put(mantisId, u.checkBranchAgainstMantis(true, mantisId)); // cvsBrCommit: true
+			e = new HashMap<String, String>();  
+			e.put(CvsUtil.mExists, true+"");
+			e.put(CvsUtil.cvsBrCommit, true+"");
+			e.put(CvsUtil.mHasBrCommits, false+"");
+			e.put(CvsUtil.mHasHdCommits, false+"");
+			//e.put(CvsUtil.mHasPtKWord, false+"");
+			//e.put(CvsUtil.ptMantis, true+"");
+			//e.put(CvsUtil.hdMantis, false+"");
+			e.put(CvsUtil.isOk, true+"");
+			me.put(mantisId, e);
+		}
+
+		if (do2458311) {
+			mantisId = new Integer("2458311"); // 2458311 does not exist
+			mr.put(mantisId, u.checkBranchAgainstMantis(false, mantisId)); // cvsBrCommit: false
+			e = new HashMap<String, String>();  
+			e.put(CvsUtil.mExists, false+"");
+			e.put(CvsUtil.cvsBrCommit, false+"");
+			e.put(CvsUtil.mHasBrCommits, false+"");
+			e.put(CvsUtil.mHasHdCommits, false+"");
+			//e.put(CvsUtil.mHasPtKWord, false+"");
+			//e.put(CvsUtil.ptMantis, false+"");
+			//e.put(CvsUtil.hdMantis, false+"");
+			e.put(CvsUtil.isOk, false+"");
+			me.put(mantisId, e);
+		}
+
+		if (do24583) {
+			mantisId = new Integer("24583"); // 24583 is a HEAD mantis
+			mr.put(mantisId, u.checkBranchAgainstMantis(false, mantisId)); // cvsBrCommit: false
+			e = new HashMap<String, String>();  
+			e.put(CvsUtil.mExists, true+"");
+			e.put(CvsUtil.cvsBrCommit, false+"");
+			e.put(CvsUtil.mHasBrCommits, false+"");
+			e.put(CvsUtil.mHasHdCommits, true+"");
+			//e.put(CvsUtil.mHasPtKWord, false+"");
+			//e.put(CvsUtil.ptMantis, false+"");
+			//e.put(CvsUtil.hdMantis, true+"");
+			e.put(CvsUtil.isOk, true+"");
+			me.put(mantisId, e);
+		}
+
+		if (do24912) {
+			mantisId = new Integer("24912"); // 24912 is a Patch mantis
+			mr.put(mantisId, u.checkBranchAgainstMantis(true, mantisId)); // cvsBrCommit: true
+			e = new HashMap<String, String>();  
+			e.put(CvsUtil.mExists, true+"");
+			e.put(CvsUtil.cvsBrCommit, true+"");
+			e.put(CvsUtil.mHasBrCommits, true+"");
+			e.put(CvsUtil.mHasHdCommits, false+"");
+			//e.put(CvsUtil.mHasPtKWord, true+"");
+			//e.put(CvsUtil.ptMantis, true+"");
+			//e.put(CvsUtil.hdMantis, false+"");
+			e.put(CvsUtil.isOk, true+"");
+			me.put(mantisId, e);
+		}
+
+		if (do24875) {
+			mantisId = new Integer("24875"); // 24875 is a HEAD mantis
+			mr.put(mantisId, u.checkBranchAgainstMantis(false, mantisId)); // cvsBrCommit: false
+			e = new HashMap<String, String>();  
+			e.put(CvsUtil.mExists, true+"");
+			e.put(CvsUtil.cvsBrCommit, false+"");  // should be
+			e.put(CvsUtil.mHasBrCommits, false+"");
+			e.put(CvsUtil.mHasHdCommits, false+"");
+			//e.put(CvsUtil.mHasPtKWord, false+"");
+			//e.put(CvsUtil.ptMantis, false+"");
+			//e.put(CvsUtil.hdMantis, true+"");
+			e.put(CvsUtil.isOk, true+"");
+			me.put(mantisId, e);
+		}
+
+		Set<Integer> mrKeys = mr.keySet();
+		boolean fail = false;
+		for (Iterator<Integer> mrIt = mrKeys.iterator(); mrIt.hasNext();) {
+			Integer mrKey = (Integer) mrIt.next();
+			r = mr.get(mrKey);
+			e = me.get(mrKey);
+
+			String s = "";
+			s += CvsUtil.rget(CvsUtil.mExists, r, e);
+			s += CvsUtil.rget(CvsUtil.cvsBrCommit, r, e);
+			s += CvsUtil.rget(CvsUtil.mHasBrCommits, r, e);
+			s += CvsUtil.rget(CvsUtil.mHasHdCommits, r, e);
+			//s += CvsUtil.rget(CvsUtil.mHasPtKWord, r, e);
+			//s += CvsUtil.rget(CvsUtil.ptMantis, r, e);
+			//s += CvsUtil.rget(CvsUtil.hdMantis, r, e);
+			s += CvsUtil.rget(CvsUtil.isOk, r, e);
+
+			//Set<String> rKeys = r.keySet();
+			//for (Iterator<String> rIt = rKeys.iterator(); rIt.hasNext();) {
+			//	String rKey = (String) rIt.next();
+			//	s += u.rget(rKey, r, e);
+			//}
+			s += "mantis:"+mrKey+" ";
+			//s += "\n";
+			if (s.contains(":tf ") || s.contains(":ft ")) {
+				System.err.println(s);
+				fail = true;
+			}
+			else {
+				System.out.println(s);
+			}
+		}
+		if (fail) {
+			fail();
+		}
+	}
+}
